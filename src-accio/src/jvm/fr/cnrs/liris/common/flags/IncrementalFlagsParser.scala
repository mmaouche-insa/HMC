// Large portions of code are copied from Google's Bazel.
/*
 * Copyright 2014 The Bazel Authors. All rights reserved.
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the
 * NOTICE file distributed with this work for additional information regarding copyright ownership.  The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License
 * for the specific language governing permissions and limitations under the License.
 */

package fr.cnrs.liris.common.flags

import fr.cnrs.liris.common.reflect.CaseClassField

import scala.collection.mutable
import scala.reflect.runtime.universe._

private[flags] class IncrementalFlagsParser(flagsData: FlagsData) {
  /**
   * Results of parsing the arguments. This map is modified by repeated calls to [[parse()]].
   */
  private val _parsedValues = mutable.Map.empty[CaseClassField, ParsedFlagEntry]

  /**
   * Pre-parsed, explicit flags for each priority. We use partially preparsed flags, which can
   * be different from the original representation, e.g. "-nofoo" becomes "-foo=0".
   */
  private val _unparsedValues = mutable.ListBuffer.empty[UnparsedFlagValueDescription]

  /**
   * Unparsed values for use with the canonicalize command are stored separately from
   * unparsedValues so that invocation policy can modify the values for canonicalization (e.g.
   * override user-specified values with default values) without corrupting the data used to
   * represent the user's original invocation for [[FlagsParser.asListOfExplicitFlags]] and
   * [[FlagsParser.asListOfUnparsedFlags]]. A LinkedHashMap is used so that canonicalization
   * happens in the correct order.
   */
  private val _canonicalValues = new mutable.LinkedHashMap[CaseClassField, UnparsedFlagValueDescription]

  /**
   * List of warnings generated during parsing.
   */
  private val _warnings = mutable.ListBuffer.empty[String]

  /**
   * Return a list of new warnings that were generated by calls to [[parse()]].
   */
  def warnings: Seq[String] = _warnings.toList

  def unparsedValues: Seq[UnparsedFlagValueDescription] = _unparsedValues.toList

  def canonicalValues: Seq[UnparsedFlagValueDescription] = _canonicalValues.values.toSeq

  def parsedValues: Map[CaseClassField, ParsedFlagEntry] = _parsedValues.toMap

  /**
   * Parses the args, and returns what it doesn't parse. May be called multiple times, and may be
   * called recursively. Calls may contain intersecting sets of flags; in that case, the arg seen
   * last takes precedence.
   *
   * The method uses the invariant that if a flag has neither an implicit dependent nor an
   * expanded from value, then it must have been explicitly set.
   */
  def parse(
    priority: Priority,
    source: Option[String],
    implicitDependent: Option[String],
    expandedFrom: Option[String],
    args: Seq[String]): Seq[String] = {

    val unparsedArgs = mutable.ListBuffer.empty[String]
    val implicitRequirements = mutable.Map.empty[String, Seq[String]]
    val remainingArgs = mutable.Queue[String](args: _*)
    while (remainingArgs.nonEmpty) {
      val arg = remainingArgs.dequeue()
      if (!arg.startsWith("-")) {
        // not an option arg
        unparsedArgs += arg
      } else if (arg.equals("--")) {
        // "--" means all remaining args aren't options
        unparsedArgs ++= remainingArgs.dequeueAll(_ => true)
      } else {
        val pair = extractFieldAndValue(arg, remainingArgs)
        implicitRequirements ++= handleFieldAndValue(pair, priority, source, implicitDependent, expandedFrom)
      }
    }

    // Now parse any implicit requirements that were collected.
    implicitRequirements.foreach { case (key, vals) =>
      val requirementSource = source.map(src => s"implicit requirement of flag -$key from $src")
      val unparsed = parse(priority, requirementSource, Some(key), None, vals)
      if (unparsed.nonEmpty) {
        // Throw an assertion, because this indicates an error in the code that specified in
        // the implicit requirements for the flag(s).
        throw new AssertionError(s"Unparsed flags remain after parsing implicit flags: ${unparsed.mkString(" ")}")
      }
    }
    unparsedArgs.toList
  }

  private def maybeAddDeprecationWarning(field: CaseClassField) = {
    val option = field.annotation[Flag]
    val warning = option.deprecationWarning
    if (warning.nonEmpty) {
      _warnings += s"Flag '${option.name}' is deprecated: $warning"
    }
  }

  private def setValue(
    field: CaseClassField,
    name: String,
    value: Any,
    priority: Priority,
    source: Option[String],
    implicitDependant: Option[String],
    expandedFrom: Option[String]) =

    _parsedValues.get(field) match {
      // Warnings should not end with a '.' because the internal reporter adds one automatically.
      case Some(entry) =>
        // Override existing flag if the new value has higher or equal priority.
        if (priority.compareTo(entry.priority) >= 0) {
          if (implicitDependant.isDefined && entry.implicitDependant.isDefined) {
            if (implicitDependant != entry.implicitDependant) {
              _warnings += s"Flag '$name' is implicitly defined by both flag '${entry.implicitDependant.get}' and flag '${implicitDependant.get}'"
            }
          } else if (implicitDependant.isDefined && priority == entry.priority) {
            _warnings += s"Flag '$name' is implicitly defined by flag '${implicitDependant.get}'; the implicitly set value overrides the previous one"
          } else if (entry.implicitDependant.isDefined) {
            _warnings += s"A new value for flag '$name' overrides a previous implicit setting of that flag by flag '${entry.implicitDependant}'"
          } else if (priority == entry.priority && entry.expandedFrom.isEmpty && expandedFrom.isDefined) {
            // Create a warning if an expansion flag overrides an explicit flag.
            _warnings += s"The flag '${expandedFrom.get}' was expanded and now overrides a previous explicitly specified flag '$name'"
          }
          // Record the new value:
          _parsedValues += field -> new ParsedFlagEntry(value, priority, source, implicitDependant, expandedFrom)
        }
      case None =>
        _parsedValues.put(field, new ParsedFlagEntry(value, priority, source, implicitDependant, expandedFrom))
        maybeAddDeprecationWarning(field)
    }

  private case class FieldValuePair(field: CaseClassField, value: Option[String])

  private def extractFieldAndValue(arg: String, remainingArgs: mutable.Queue[String]) = {
    var value: Option[String] = None
    val equalsAt = arg.indexOf('=')
    var name = if (equalsAt == -1) arg.substring(1) else arg.substring(1, equalsAt)
    if (name.trim.isEmpty) {
      throw new FlagsParsingException(s"Invalid flags syntax: $arg", Some(arg))
    }
    if (equalsAt > -1) {
      value = Some(arg.substring(equalsAt + 1))
    }

    val field = if (!flagsData.fields.contains(name) && name.startsWith("no")) {
      // Look for a "no"-prefixed option name: "no<optionname>";
      // (Undocumented: we also allow -no-foo.  We're generous like that.)
      name = name.substring(if (name.startsWith("no-")) 3 else 2)
      if (value.isDefined) {
        throw new FlagsParsingException(s"Unexpected value after boolean flag: $arg", Some(arg))
      }
      // "no<optionname>" signifies a boolean option w/ false value
      value = Some("0")
      getBooleanField(name, Some(s"Illegal use of 'no' prefix on non-boolean option: $arg"))
    } else {
      getField(name)
    }

    if (value.isEmpty) {
      if (field.scalaType.runtimeClass == classOf[Unit]) {
        // Fields of type Unit are expected to have no value.
      } else if (FlagsParser.isBooleanField(field)) {
        value = Some("1")
      } else if (remainingArgs.nonEmpty) {
        value = Some(remainingArgs.dequeue()) // "-flag value" form
      } else {
        throw new FlagsParsingException(s"Expected value after $arg")
      }
    }

    FieldValuePair(field, value)
  }

  private def getField(name: String) =
    flagsData.fields.get(name) match {
      case Some(field) => field
      case None => throw new FlagsParsingException(s"Unrecognized flag: -$name", Some(s"-$name"))
    }

  private def getBooleanField(name: String, message: Option[String] = None) = {
    val field = getField(name)
    if (!FlagsParser.isBooleanField(field)) {
      throw new FlagsParsingException(message.getOrElse(s"sFlag '-$name' is not a boolean flag"), Some(s"-$name"))
    }
    field
  }

  private def handleFieldAndValue(
    pair: FieldValuePair,
    priority: Priority,
    source: Option[String],
    implicitDependent: Option[String],
    expandedFrom: Option[String]) = {

    val flag = pair.field.annotation[Flag]
    if (implicitDependent.isEmpty) {
      // Log explicit options and expanded flags in the order they are parsed (can be sorted
      // later). Also remember whether they were expanded or not. This information is needed to
      // correctly canonicalize flags.
      val unparsedOptionValueDescription = new UnparsedFlagValueDescription(flag.name, pair.field, pair.value, priority, source, expandedFrom.isEmpty)
      _unparsedValues += unparsedOptionValueDescription
      _canonicalValues(pair.field) = unparsedOptionValueDescription
    }

    // Handle expansion options.
    if (flag.expansion.nonEmpty) {
      val expansionSource = source.map(src => s"expanded from flag -${flag.name} from $src")
      maybeAddDeprecationWarning(pair.field)
      val unparsed = parse(priority, expansionSource, None, Some(flag.name), flag.expansion.toSeq)
      if (unparsed.nonEmpty) {
        // Throw an assertion, because this indicates an error in the code that specified the
        // expansion for the current option.
        throw new FlagsParsingException(s"Unparsed flags remain after parsing expansion of ${flag.name}: ${unparsed.mkString(" ")}")
      }
    } else {
      val convertedValue = if (pair.value.nonEmpty) {
        val converter = flagsData.converters(pair.field)
        try {
          converter.convert(pair.value.get)
        } catch {
          case e: FlagsParsingException =>
            // The converter doesn't know the option name, so we supply it here by re-throwing.
            throw new FlagsParsingException(s"While parsing flag ${flag.name}: ${e.getMessage}", None, e)
        }
      } else {
        Unit.box(Unit)
      }
      // We allow duplicates of single-use options across separate calls to parse(); latest wins.
      setValue(pair.field, flag.name, convertedValue, priority, source, implicitDependent, expandedFrom)
    }

    // Collect any implicit requirements.
    if (flag.implicitRequirements.nonEmpty) {
      Seq(flag.name -> flag.implicitRequirements.toSeq)
    } else {
      Seq.empty[(String, Seq[String])]
    }
  }
}

/**
 * For every value, this class keeps trace of its priority, its free-form source description,
 * whether it was set as an implicit dependency, and the value.
 */
private[flags] class ParsedFlagEntry(
  val value: Any,
  val priority: Priority,
  val source: Option[String],
  val implicitDependant: Option[String],
  val expandedFrom: Option[String]) {
  def asFlagValueDescription(fieldName: String): FlagValueDescription =
    new FlagValueDescription(fieldName, value, priority, source, implicitDependant, expandedFrom)
}
